---
title: "Simulation 1"
output:
  html_document:
    df_print: paged
---

```{r, echo = FALSE, include = FALSE, message = FALSE}
library(tidyverse)
library(DynTxRegime)
scripts <- str_subset(list.files(), ".R$")
quietly(map(scripts, source))

```


__Setup__

Data generating model.

\begin{align*}
  Q_2(h_2, a_2) &= \mathbb{E}[Y \vert H_2 = h_2, A_2 = a_2] \\
  Q_1(h_1, a_1) &= \mathbb{E}[max_{a_2} Q_2(h_2, a_2) \vert H_1 = h_1, A_1 = a_1]
\end{align*}

Then $\pi_t^{\text{opt}}(h_t) = \arg\max_{a_t}Q_t(h_t, a_t)$ for $t = 1, 2$. 

Suppose that we have 1 binary tailoring variable $X_1 \in \{-1, 1\}$, and further assume that there are no intermediate tailorinig variables. Consider

\begin{align*}
  \mathbb{E}[Y \vert X_1, A_1, A_2] = (1, X_1, A_1, X_1 A_1) \beta_0 + A_2 (1, X_1, A_1) \beta_1. 
\end{align*}

WLOG, assume that there are 6 stage 2 treatments and 4 stage 1 treatments. We will use indicators for each treatment. Thus we have 

\begin{align*}
  \mathbb{E}[Y \vert X_1, A_1, A_2] = &\beta_{00} + \beta_{01} X_1 + \beta_{02} W_1 +  \\ 
  &\beta_{02} I(A_1 == 1) + \beta_{03} I(A_1 == 2) + \beta_{04} I(A_1 == 3) + \beta_{05} I(A_1 == 4) + \\     &\beta_{06} I(A_1 == 1) X_1 + \beta_{07} I(A_1 == 2) X_1 + \beta_{08} I(A_1 == 3) X_1 + \beta_{09} I(A_1 == 4) X_1 + \\
  & I(A2 == 1)[\beta_{111} + \beta_{112} X_1 + \beta_{113} I(A1 == 1) + \beta_{114} I(A1 == 2) + \beta_{115} I(A1 == 3) + \beta_{116} I(A1 == 4) ] +\\
  & I(A2 == 2)[\beta_{121} + \beta_{122} X_1 + \beta_{123} I(A1 == 1) + \beta_{124} I(A1 == 2) + \beta_{125} I(A1 == 3) + \beta_{126} I(A1 == 4) ] +\\
  & I(A2 == 3)[\beta_{131} + \beta_{132} X_1 + \beta_{133} I(A1 == 1) + \beta_{134} I(A1 == 2) + \beta_{135} I(A1 == 3) + \beta_{136} I(A1 == 4) ] +\\
  & I(A2 == 4)[\beta_{141} + \beta_{142} X_1 + \beta_{143} I(A1 == 1) + \beta_{144} I(A1 == 2) + \beta_{145} I(A1 == 3) + \beta_{146} I(A1 == 4) ] +\\
  & I(A2 == 5)[\beta_{151} + \beta_{152} X_1 + \beta_{153} I(A1 == 1) + \beta_{154} I(A1 == 2) + \beta_{155} I(A1 == 3) + \beta_{156} I(A1 == 4) ] +\\
  & I(A2 == 6)[\beta_{161} + \beta_{162} X_1 + \beta_{163} I(A1 == 1) + \beta_{164} I(A1 == 2) + \beta_{165} I(A1 == 3) + \beta_{166} I(A1 == 4) ] 
\end{align*}

Next we can specify $\beta_0$ and $\beta_1$



```{r}

beta0 <- c(.3, .25, 0.1, 0.4, -0.4, .2, -.2, .3, -.3, 0, .2)
beta1_1 <- c(0, -0.4, 0, 0, 0.4, -0.4)
beta1_2 <- c(-0.4, .3, .2, -0.4, 0, .2)
beta1_3 <- c(.2, 0.4, 0, 0, -.2, 1)
beta1_4 <- c(.2, 0, -0.4, -.3, 0, .2)
beta1_5 <- c(0.4, -0.4, 0, 0, .2, .2)
beta1_6 <- c(0, .2, .2, -0.4, -0.4, -0.4)
beta1 <- list(beta1_1, beta1_2, beta1_3, beta1_4, beta1_5, beta1_6)


# Model specification
moMain <- modelObj::buildModelObj(model = ~ X_1 + X_2 + X_3 + W_1,
                                  solver.method = 'lm')
moCont <- moMain
```



```{r, include=FALSE, echo=FALSE, message = FALSE}
# Alternate version of make binary covariates to make them take values in {-1, 1}
makeBinaryCovars <- function(df, numCovars, props){
  if(numCovars < 0){
    warning("Number of binary covariates must be non-negative")
  } else if(numCovars == 0){
    return(df)
  } else{
    covarNames <- paste("X", 1:numCovars, sep = "_")
    for(i in 1:numCovars){
      df <- df %>% rowwise() %>%
        mutate(!!sym(covarNames[i]) := 2*rbinom(n = 1, size = 1, prob = props[i])-1) %>%
        ungroup()
    }
    return(df)
  }
}
```

```{r metadata, echo=FALSE, include=FALSE}
metadata <- list(N = 600,
                 firstLineTreatments = as.character(1:4),
                 secondLineTreatments = as.character(1:6),
                 standardOfCareTreatment = "1")

args <- list(
  makePpts_fn = "makePpts",
  makePpts_args = list(metadata[["N"]]),
  makeCovariates_fn = "covariateFn_v1",
  makeCovariates_args = list(numBinaryCovars = 3, props = c(0.6, 0.2, 0.4),
                             numNormalCovars = 1, mu = 0, sd = 1),
  allocateStage1Treatments_fn = "allocationFn_stage1_v1",
  allocateStage1Treatments_args = list(metadata$firstLineTreatments),
  generateY1_fn = "generateNormalY1",
  generateY1_args = list(intercept = 0.3, 
               coefs = c("X_1" = .25, "W_1" = .1, 
                         "A1_1" = 0.4,
                         "A1_2" = -0.4,
                         "A1_3" = 0.25,
                         "A1_4" = 0.25,
                         "A1_1*X_1" = 0.3,
                         "A1_2*X_1" = 0.3,
                         "A1_4*X_1" = 0.2), 
               sigma = sqrt(0.5)),
  assignResponderStatus_fn = "assignResponderStatusByQuantile",
  assignResponderStatus_args = list(ctsOutcome1 = "Y1", cutoffs = c(0.2, 0.8)),
  allocateStage2Treatments_fn = "allocationFn_stage2_v1",
  allocateStage2Treatments_args = list(firstLineTreatments = metadata$firstLineTreatments,
                                       secondLineTreatments = metadata$secondLineTreatments,
                                       augmentationTreatments = metadata$augmentationTreatments,
                                       standardOfCareTreatment = metadata$standardOfCareTreatment),
  generateY2_fn = "generateY2Fn_v1",
  generateY2_args = list(coefs = c(
    "A2_1*X_1" = -0.4, "A2_1*A1_3" = -0.4, "A2_1*A1_4" = 0.4,
    "A2_2" = -0.4, "A2_2*X_1" = 0.3, "A2_2*A1_1" = 0.2, "A2_2*A1_2" = -0.4, "A2_2*A1_3" = 0, "A2_2*A1_4" = 0.2,    
    "A2_3" = 0.2, "A2_3*X_1" = 0.4, "A2_3*A1_1" = 0, "A2_3*A1_2" = 0, "A2_3*A1_3" = -0.2, "A2_3*A1_4" = 0.4,
    "A2_4" = 0.2, "A2_4*X_1" = 0, "A2_4*A1_1" = -1, "A2_4*A1_2" = -0.3, "A2_4*A1_3" = 0, "A2_4*A1_4" = 0.2,  
    "A2_5" = 0.4, "A2_5*X_1" = -0.4, "A2_5*A1_1" = 0, "A2_5*A1_2" = 0, "A2_5*A1_3" = 0.2, "A2_5*A1_4" = 0.2,
    "A2_6" = 0, "A2_6*X_1" = 0.2, "A2_6*A1_1" = 0.2, "A2_6*A1_2" = -0.4, "A2_6*A1_3" = -0.4, "A2_6*A1_4" = -0.4),
    sigma = sqrt(0.5)),
  generateY_fn = "setYtoY2",
  generateY_args = list(NA))



```



```{r treatment_grid, echo=FALSE, include=FALSE}
possibleTreatmentSequences <- generatePossibleTreatmentSequencesGrid(
  first_line_trts = metadata$firstLineTreatments,
  second_line_trts = metadata$secondLineTreatments,
  augment_trts = metadata$augmentationTreatments,
  impermissible_trt_pairs_df = NULL)
```



```{r, cache = TRUE}
set.seed(8430)
# NC Pick 4 Daytime Draw 
# https://nclottery.com/Pick4

metadata_list <- map(c(600, 800, 1000), ~list_modify(metadata, N = .))
args_list <- map(c(600, 800, 1000), ~list_modify(args, makePpts_args = list(.)))



# Create L data sets
L <- 500
sim_data_list <- map2(.x = metadata_list, 
                      .y = args_list,
                      ~map(1:L, makeSimDataWrapper, metadata = .x, args = .y))
```


__Evaluate Out-of-sample performance__

Generate new out of sample data from the same population
```{r oos_data, cache = TRUE}
oosDF <- makePpts(N = 1e4) %>%
   exec(args$makeCovariates_fn, !!!args$makeCovariates_args, df = .) 
```


And their expected and potential outcomes under all possible treatments
```{r expectations_and_pos, cache = TRUE}
# 
oosPOs <- oosDF %>% 
  calcTrueMeansAndPOs(indf = .,
                      trt_options_grid = possibleTreatmentSequences,
                      outcome_functions_list = list(args$generateY1_fn, 
                                                    args$generateY2_fn,
                                                    args$assignResponderStatus_fn,
                                                    args$generateY_fn),
                      outcome_args_list = list(args$generateY1_args,
                                               args$generateY2_args,
                                               args$assignResponderStatus_args,
                                               args$generateY_args)) %>% 
  calcOptTxAndValFromPOs(.)

opt_tx_summary <- summarizeOptTxAndValFromPOs(oosPOs, "X_1")

# Show the optimal sequences
opt_tx_summary %>% group_by(X_1, OptA1, OptA2) %>% 
  summarise(Value = round(mean(maxMu),1), .groups = 'drop')
```

Predict Treatment Sequences and Calculate the Corresponding Value

```{r, analysis_wrapper, echo = FALSE, include = FALSE}

simAnalysisWrapper <- function(sim_data_list_single_setting){
  res_both_stages <- map(sim_data_list_single_setting, doQLearningListReturn, moMain_stage2 = moMain, moCont_stage2 = moCont,
            moMain_stage1 = moMain, moCont_stage1 = moCont)
  
  oosTrtSeqEstimates <- map(res_both_stages, ~predictTreatSequence(., newdata = oosDF))
  
  oosVals <- map_dfr(oosTrtSeqEstimates, ~getValueDifSummary(., po_grid_df = oosPOs))
  oosVals$N <- nrow(sim_data_list_single_setting[[1]])
  
  return(oosVals)

}



```

```{r analysis_results, echo = FALSE, include = FALSE}
run_analysis_flag <- TRUE
save_analysis_flag <- TRUE

# Got a weird cache error so here's a janky workaround

if (run_analysis_flag == TRUE) {
  analysis_results <- map(sim_data_list, ~simAnalysisWrapper(.))
} else{
  analysis_results <- readRDS("sim1_analysis.rds")
}
if (save_analysis_flag == TRUE) saveRDS(analysis_results, "sim1_analysis.rds")
```

```{r, echo = FALSE, include = FALSE}
sim_summaries <- bind_rows(analysis_results) %>% 
  mutate_at(., .vars = "N", ~factor(., ordered = TRUE))
```

```{r, echo = FALSE, warning = FALSE}
cbp1 <- c("#999999", "#E69F00", "#56B4E9", "#009E73",
          "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

#ggplot(data = sim_summaries, aes(x = PercOracle, color = N)) + 
#  geom_density() + 
#  scale_colour_manual(values = cbp1) + 
#  labs(x = "Percentage of Oracle Value")

cutoffHelper <- function(indf, cutoff.val){
  to_return <- indf %>% group_by(N) %>% 
    summarise(Power = sum(PercOracle > cutoff.val)/n(),
              .groups = "drop_last") %>% 
    mutate(Cutoff = cutoff.val)
  
  return(to_return)
}

perc_oracle_power <- map_dfr(c(seq(0, .5, by = .1), seq(0.5, 1, by = .005)), ~cutoffHelper(indf = sim_summaries, cutoff.val = .))

ggplot(data = perc_oracle_power, aes(x = Cutoff, y = Power, color = N)) + 
  geom_line() + 
  xlim(0, 1)+
  ylim(0,1)+
  scale_colour_manual(values = cbp1) + 
  labs(x = "Percentage of Oracle Value Cutoff",
       y = "Probability of Attaining Value Above Cutoff")
```

Use the predicted treatment sequence and our lookup table of values to 
get the value of the fitted DTR and percentage of oracle value. 



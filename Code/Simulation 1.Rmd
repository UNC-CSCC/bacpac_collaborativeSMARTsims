---
title: "Simulation 1"
output:
  html_document:
    df_print: paged
---

```{r, echo = FALSE, include = FALSE, message = FALSE}
library(tidyverse)
library(DynTxRegime)
scripts <- str_subset(list.files(), ".R$")
quietly(map(scripts, source))
```


__Setup__

Data generating model.

\begin{align*}
  Q_2(h_2, a_2) &= \mathbb{E}[Y \vert H_2 = h_2, A_2 = a_2] \\
  Q_1(h_1, a_1) &= \mathbb{E}[max_{a_2} Q_2(h_2, a_2) \vert H_1 = h_1, A_1 = a_1]
\end{align*}

Then $\pi_t^{\text{opt}}(h_t) = \arg\max_{a_t}Q_t(h_t, a_t)$ for $t = 1, 2$. 

Suppose that we have 1 binary tailoring variable $X_1 \in \{-1, 1\}$, and further assume that there are no intermediate tailorinig variables. Consider

\begin{align*}
  \mathbb{E}[Y \vert X_1, A_1, A_2] = (1, X_1, A_1, X_1 A_1) \beta_0 + A_2 (1, X_1, A_1) \beta_1. 
\end{align*}

WLOG, assume that there are 6 stage 2 treatments and 4 stage 1 treatments. We will use indicators for each treatment. Thus we have 

\begin{align*}
  \mathbb{E}[Y \vert X_1, A_1, A_2] = &\beta_{00} + \beta_{01} X_1 + \\
  &\beta_{02} I(A_1 == 1) + \beta_{03} I(A_1 == 2) + \beta_{04} I(A_1 == 3) + \beta_{05} I(A_1 == 4) + \\     &\beta_{06} I(A_1 == 1) X_1 + \beta_{07} I(A_1 == 2) X_1 + \beta_{08} I(A_1 == 3) X_1 + \beta_{09} I(A_1 == 4) X_1 + \\
  & I(A2 == 1)[\beta_{111} + \beta_{112} X_1 + \beta_{113} I(A1 == 1) + \beta_{114} I(A1 == 2) + \beta_{115} I(A1 == 3) + \beta_{116} I(A1 == 4) ] +\\
  & I(A2 == 2)[\beta_{121} + \beta_{122} X_1 + \beta_{123} I(A1 == 1) + \beta_{124} I(A1 == 2) + \beta_{125} I(A1 == 3) + \beta_{126} I(A1 == 4) ] +\\
  & I(A2 == 3)[\beta_{131} + \beta_{132} X_1 + \beta_{133} I(A1 == 1) + \beta_{134} I(A1 == 2) + \beta_{135} I(A1 == 3) + \beta_{136} I(A1 == 4) ] +\\
  & I(A2 == 4)[\beta_{141} + \beta_{142} X_1 + \beta_{143} I(A1 == 1) + \beta_{144} I(A1 == 2) + \beta_{145} I(A1 == 3) + \beta_{146} I(A1 == 4) ] +\\
  & I(A2 == 5)[\beta_{151} + \beta_{152} X_1 + \beta_{153} I(A1 == 1) + \beta_{154} I(A1 == 2) + \beta_{155} I(A1 == 3) + \beta_{156} I(A1 == 4) ] +\\
  & I(A2 == 6)[\beta_{161} + \beta_{162} X_1 + \beta_{163} I(A1 == 1) + \beta_{164} I(A1 == 2) + \beta_{165} I(A1 == 3) + \beta_{166} I(A1 == 4) ] 
\end{align*}

Next we can specify $\beta_0$ and $\beta_1$



```{r}
beta0 <- c(.3, .25, 1, -1, .5, -.5, .75, -.75, 0, .2)
beta1_1 <- c(0, -1, 0, 0, 1, -1)
beta1_2 <- c(-1, .75, .5, -1, 0, .5)
beta1_3 <- c(.5, 1, 0, 0, -.5, 1)
beta1_4 <- c(.5, 0, -1, -.75, 0, .5)
beta1_5 <- c(1, -1, 0, 0, .5, .5)
beta1_6 <- c(0, .5, .5, -1, -1, -1)
beta1 <- list(beta1_1, beta1_2, beta1_3, beta1_4, beta1_5, beta1_6)

```



```{r, include=FALSE, echo=FALSE, message = FALSE}
# Alternate version of make binary covariates to make them take values in {-1, 1}
makeBinaryCovars <- function(df, numCovars, props){
  if(numCovars < 0){
    warning("Number of binary covariates must be non-negative")
  } else if(numCovars == 0){
    return(df)
  } else{
    covarNames <- paste("X", 1:numCovars, sep = "_")
    for(i in 1:numCovars){
      df <- df %>% rowwise() %>%
        mutate(!!sym(covarNames[i]) := 2*rbinom(n = 1, size = 1, prob = props[i])-1) %>%
        ungroup()
    }
    return(df)
  }
}
```

Same as above except the addition of a single continuous covariate $W_1$ with an associated parameter of 0.1. 

```{r}
metadata <- list(N = 600,
                 firstLineTreatments = as.character(1:4),
                 secondLineTreatments = as.character(1:6),
                 standardOfCareTreatment = "1")

args <- list(
  makePpts_fn = "makePpts",
  makePpts_args = list(metadata[["N"]]),
  makeCovariates_fn = "covariateFn_v1",
  makeCovariates_args = list(numBinaryCovars = 3, props = c(0.6, 0.5, 0.4),
                             numNormalCovars = 1, mu = 0, sd = 1),
  allocateStage1Treatments_fn = "allocationFn_stage1_v1",
  allocateStage1Treatments_args = list(metadata$firstLineTreatments),
  generateY1_fn = "generateNormalY1",
  generateY1_args = list(intercept = 0.3, 
               coefs = c("X_1" = .25, "W_1" = .1, 
                         "A1_1" = 1,
                         "A1_2" = -1,
                         "A1_3" = 0.5,
                         "A1_4" = 0.5,
                         "A1_1*X_1" = 0.75,
                         "A1_2*X_1" = 0.75,
                         "A1_4*X_1" = 0.2), 
               sigma = 1),
  assignResponderStatus_fn = "assignResponderStatusByQuantile",
  assignResponderStatus_args = list(ctsOutcome1 = "Y1", cutoffs = c(0.2, 0.8)),
  allocateStage2Treatments_fn = "allocationFn_stage2_v1",
  allocateStage2Treatments_args = list(firstLineTreatments = metadata$firstLineTreatments,
                                       secondLineTreatments = metadata$secondLineTreatments,
                                       augmentationTreatments = metadata$augmentationTreatments,
                                       standardOfCareTreatment = metadata$standardOfCareTreatment),
  generateY2_fn = "generateY2Fn_v1",
  generateY2_args = list(coefs = c(
    "A2_1*X_1" = -1, "A2_1*A1_3" = -1, "A2_1*A1_4" = 1,
    "A2_2" = -1, "A2_2*X_1" = 0.75, "A2_2*A1_1" = 0.5, "A2_2*A1_2" = -1, "A2_2*A1_3" = 0, "A2_2*A1_4" = 0.5,    
    "A2_3" = 0.5, "A2_3*X_1" = 1, "A2_3*A1_1" = 0, "A2_3*A1_2" = 0, "A2_3*A1_3" = -0.5, "A2_3*A1_4" = 1,
    "A2_4" = 0.5, "A2_4*X_1" = 0, "A2_4*A1_1" = -1, "A2_4*A1_2" = -0.75, "A2_4*A1_3" = 0, "A2_4*A1_4" = 0.5,  
    "A2_5" = 1, "A2_5*X_1" = -1, "A2_5*A1_1" = 0, "A2_5*A1_2" = 0, "A2_5*A1_3" = 0.5, "A2_5*A1_4" = 0.5,
    "A2_6" = 0, "A2_6*X_1" = 0.5, "A2_6*A1_1" = 0.5, "A2_6*A1_2" = -1, "A2_6*A1_3" = -1, "A2_6*A1_4" = -1),
    sigma = 1),
  generateY_fn = "setYtoY2",
  generateY_args = list(NA))

```



```{r treatment_grid}
possibleTreatmentSequences <- generatePossibleTreatmentSequencesGrid(
  first_line_trts = metadata$firstLineTreatments,
  second_line_trts = metadata$secondLineTreatments,
  augment_trts = metadata$augmentationTreatments,
  impermissible_trt_pairs_df = NULL)
```



```{r}
set.seed(309482)

# Create L data sets
L <- 100
allSimData <- map(1:L, makeSimDataWrapper, metadata = metadata, args = args)
```


```{r}
moMain <- modelObj::buildModelObj(model = ~ X_1 + X_2 + X_3 + W_1,
                                  solver.method = 'lm')
moCont <- moMain

res <- map(allSimData, doQLearning, moMain_stage2 = moMain, moCont_stage2 = moCont,
            moMain_stage1 = moMain, moCont_stage1 = moCont)

res_both_stages <- map(allSimData, doQLearningListReturn, moMain_stage2 = moMain, moCont_stage2 = moCont,
            moMain_stage1 = moMain, moCont_stage1 = moCont)

estimatedValues <- map(res, estimator)

unlist(estimatedValues)
```

__Step 6__ Evaluate Out-of-sample performance

Generate new out of sample data from the same population
```{r oos_data}
# Set to 1e4
oosDF <- makePpts(N = 1e4) %>%
   exec(args$makeCovariates_fn, !!!args$makeCovariates_args, df = .) 
```


And their expected and potential outcomes under all possible treatments
```{r expectations_and_pos}
oosPOs <- oosDF %>% 
  calcTrueMeansAndPOs(indf = .,
                      trt_options_grid = possibleTreatmentSequences,
                      outcome_functions_list = list(args$generateY1_fn, 
                                                    args$generateY2_fn,
                                                    args$assignResponderStatus_fn,
                                                    args$generateY_fn),
                      outcome_args_list = list(args$generateY1_args,
                                               args$generateY2_args,
                                               args$assignResponderStatus_args,
                                               args$generateY_args)) %>% 
  calcOptTxAndValFromPOs(.)

opt_tx_summary <- summarizeOptTxAndValFromPOs(oosPOs)

```

Predict Treatment Sequences

```{r}

oosTrtSeqEstimates <- map(res_both_stages, ~predictTreatSequence(., newdata = oosDF))


```

Use the predicted treatment sequence and our lookup table of values to 
get the value of the fitted DTR and percentage of oracle value. 

```{r}
oosVals <- map_dfr(oosTrtSeqEstimates, ~getValueDifSummary(., po_grid_df = oosPOs))
head(oosVals)

summary(oosVals$PercOracle)
```

# Functions for Potential Outcomes 
# Author: John Sperger
# Last modified on 01 December 2020


################################################################################
### Design idea:
# Create a large out-of-sample look-up table where every out-of-sample person
# has the expected values and potential outcomes for every treatment order/combination
#
# Take an arbitrary set of 
#   (categorical) treatments, 
#   outcome generation functions (optionally incuding responder status functions
# 
# 
# Be able to create counterfactuals for existing data. This requires ensuring that
# the potential outcomes for the treatment received match the observed outcomes
#
### Current assumptions:
# - The treatment options are categorical or ordinal
# - Generate a long data frame and rely on the analysis functions to group
# - Treatment names are A1 and A2
# - Outcome names are Y1, Y2, and Y (overall outcome)
# 
### Process
# Simulate a large out-of-sample cohort
# Pre-calculate the expected value and potential outcomes for every possible treatment sequence
# Oracle function has access to the true E[Y_1|X, do(A_1)] but not Y_1 | X, do(A_1)
#
### TODO Near future
#
#
### TODO Someday/maybe
# Use an optimization solver instead of a tabular simulation
# Add support for continuous treatments
#  
# 
################################################################################

#' Calculate the true mean and potential outcomes for all outcome combinations
#' @param indf data frame containing ptids and covariates perhaps as generated by \code{makeCovariates}
#' @param widen Logical variable indicating whether a wide dataframe or a long dataframe should be returned. If 
#' wide, the expectations and potential outcomes have names Mu{stage#}_{outcome#}
#' and PO{stage#}_{outcome#}
#' @param trt_options_grid data frame where rows are valid treatment sequences and columns are stages
#' @param outcome_function_list list whose entries are character strings of function names. Entries are called sequentially
#' @param outcome_args_list list whose entries are named lists with arguments 
#' passed to \code{outcome_function_list}. Entries are passed sequentially. 
#' Currently, there must be an empty placeholder entry even if the corresponding
#' function in \code{outcome_function_list} does not require additional arguments
#' @return dataframe with expectations and potential outcomes

calcTrueMeansAndPOs <- function(indf,
                                trt_options_grid = NULL,
                                outcome_functions_list,
                                outcome_args_list){
  # Check some basic conditions
  stopifnot(length(outcome_functions_list) == length(outcome_args_list))
  if(any(c("A1", "A2") %in% colnames(indf) == TRUE)) {
    a1_mismatches <- setdiff(unique(indf$A1), unique(trt_options_grid$A1))
    a2_mismatches <- setdiff(unique(indf$A2), unique(trt_options_grid$A2))
    
    if(is_empty(a1_matches)  == FALSE | is_empty(a1_matches) == FALSE){
      a1_mismatches_string <- paste(sort(a1_mismatches), collapse = ", ")
      a2_mismatches_string <- paste(sort(a2_mismatches), collapse = ", ")
      
      mismatch_error_msg <- paste0("Mismatch in treatments between indf and and trt_options_grid. \n", 
                               "Differences in A1: ", a1_mismatches_string, "\n",
                               "Differences in A2: ", a2_mismatches_string)
      
      stop(mismatch_error_msg)
    }
  }
  
  indf_with_pos <- .calcMuCreatePOShellLong(patient_df = indf,
                                                possible_treatments_df = trt_options_grid) %>% 
    .calcMuGenExpectations(mudf = .,
                                  new_varname_prefix = "Mu",
                                  outcome_functions_list = outcome_functions_list,
                                  outcome_args_list = outcome_args_list) %>% 
    .calcMuGenPOs(podf = .,
                         new_varname_prefix = "PO",
                         outcome_functions_list = outcome_functions_list,
                         outcome_args_list = outcome_args_list) %>% 
    .calcPOsForcePOEqualsObserved(po_df = .,
                                  patient_df = indf) %>% 
    .calcOptTxAndValFromPOs(.)
  
  
  return(indf_with_pos)
}


#' Create a long data frame by repeating the treatment option grid for every
#' patient in the input data frame. The function strips out existing treatment 
#' assignments and responses
#' @param patient_df
#' @param possible_treatments_df
.calcMuCreatePOShellLong <- function(patient_df,
                                     possible_treatments_df) {
  stopifnot("ptid" %in% colnames(patient_df))
  if (nrow(patient_df) != length(unique(patient_df$ptid))) stop("Patient data frame must not contain duplicate ptids")
  
  
  trts_and_outcomes_to_drop <- c("A1", "A2", "Y1", "Y2", "Y",
                                 "pctRank", "respStatus")
  
  po_shell <- possible_treatments_df %>% 
    slice(rep(1:n(), times = nrow(patient_df))) %>% 
    mutate(ptid = rep(patient_df$ptid, each = nrow(possible_treatments_df))) %>% 
    full_join(., 
              y = patient_df %>% 
                select(-any_of(trts_and_outcomes_to_drop)) %>% 
                select(-starts_with("A1"), -starts_with("A2")), 
              by = "ptid")
  
  return(po_shell)
}


#' Generates potential outcomes. This is very similar to normal data generation except
#' some additional tidying up is done at the end. 
#' \code{.calcMuGenPOs}
.calcMuGenPOs <- function(podf,
                                 new_varname_prefix = "PO",
                                 outcome_functions_list,
                                 outcome_args_list){
  # Variables in this vector will be renamed {new_varname_prefix}{varname}
  special_var_names <- c("pctRank", "respStatus", "consistent")
  
  for(cur_index in 1:length(outcome_args_list)){
    
    podf <- podf %>% 
      exec(outcome_functions_list[[cur_index]], !!!outcome_args_list[[cur_index]], df = .)
    
  }
  
  # Current outcome data generation functions generate these A1_ and A2_  variables
  # Because we'll be calling these functions multiple times (once for Mu, once for PO)
  # we want to avoid name collisions.
  
  podf <- podf %>% 
    .calcMuRenameVarsAndRemoveVars(indf = .,
                      new_varname_prefix = new_varname_prefix,
                      special_var_names = special_var_names)
  
  return(podf)
  
}


#' Generates expectations by setting noise terms to zero and then calling
#' \code{.calcMuGenPOs}
.calcMuGenExpectations <- function(mudf,
                                 new_varname_prefix = "Mu",
                                 outcome_functions_list,
                                 outcome_args_list){
  
  # Generates expectations by setting the noise term to zero
  for(cur_index in 1:length(outcome_args_list)){
   if ("sigma" %in% names(outcome_args_list[[cur_index]])){
     outcome_args_list[[cur_index]]$sigma <- 0
   } 
    
    if ("sigma.noise" %in% names(outcome_args_list[[cur_index]])){
      outcome_args_list[[cur_index]]$sigma.noise <- 0
    } 
  }
  
  mudf <- .calcMuGenPOs(podf = mudf,
                               new_varname_prefix = new_varname_prefix,
                               outcome_functions_list = outcome_functions_list,
                               outcome_args_list = outcome_args_list)
  
  
  return(mudf)
  
}
#' A little helper function that 
#' 1) Removes treatment indicators (the variables A1_1 not A1)
#' 2) Renames Outcome variables from Y{foo} to {new_varname_prefix}{foo}
#' 3) Renames the variables in special_var_names to {new_varname_prefix}{special_var_names} 
#' 
#' 
.calcMuRenameVarsAndRemoveVars <- function(indf,
                              new_varname_prefix,
                              special_var_names){
  indf <- indf %>% 
    select(-starts_with("A1_"), -starts_with("A2_")) %>% 
    rename_with(., .fn = ~str_replace(string = ., "Y", new_varname_prefix), starts_with("Y")) %>% 
    rename_with(., .fn = ~paste0(new_varname_prefix, .), any_of(special_var_names))
  
  return(indf)
}

#' 
#' @param po_df data frame with the potential outcomes
#' @param patient_df patient data frame with the observed outcomes
#' @return the data frame of potential outcomes where the potential outcome has 
#' been replaced with the observed outcome for the cases where
#' the potential and observed treatment sequence matches
.calcPOsForcePOEqualsObserved <- function(po_df, patient_df){
  if (any(c("Y1", "Y2", "Y") %in% colnames(patient_df)) == FALSE) return(po_df)
  
  special_var_names <- c("pctRank", "respStatus", "consistent")
  
  patient_trts_and_outcomes_only <- patient_df %>% 
    .calcMuRenameVarsAndRemoveVars(indf = ., new_varname_prefix = "PO",
                                   special_var_names = special_var_names)
  updated_po_df <- po_df %>% 
    rows_update(., y = patient_trts_and_outcomes_only, by = c("ptid", "A1", "A2"))

  return(updated_po_df)
}


#' Create a wide data frame from the long potential outcomes data frame
#' @param df_to_pivot the long expectations and potential outcomes data frame
#' @return a wide data frame where the expectations and potential outcomes have
#' variables names {Mu/PO}{stage#}_{trt#}
.calcMuPivotWide <- function(df_to_pivot){
  stop("This function is not currently working")
  stage_one_vars <- c("ptid", "A1", "Mu1", "PO1")
  stage_two_vars <- c("ptid", "A1", "A2", "Mu2", "PO2")

    stage_one_pos_wide_df <- df_to_pivot %>% 
    select(ptid, A1, Mu1, PO1) %>% 
    distinct_at(., .vars = c("ptid", "A1"), .keep_all = TRUE) %>% 
    pivot_wider(names_from = "A1",
                names_sep = "_",
                values_from = c("Mu1", "PO1")) 
  
  stage_two_pos_wide_df <- df_to_pivot %>% 
    select(ptid, A1, A2, Mu2, PO2) %>% 
    #distinct_at(., .vars = c("ptid", "A2"), .keep_all = TRUE) %>% 
    pivot_wider(names_from = c("A1", "A2"),
                names_sep = "_",
                values_from = c("Mu2", "PO2"))
  
  final_pos_wide_df <- df_to_pivot %>% 
    select(ptid, A1, A2, Y) %>% 
    pivot_wider(names_from = c("A1", "A2"),
                names_prefix = "Y_",
                values_from = "Y")
  
  pos_wide_df <- full_join(stage_one_pos_wide_df,
                           stage_two_pos_wide_df,
                           by = "ptid") %>% 
    full_join(., final_pos_wide_df, by = "ptid")
  
  return(pos_wide_df)
}


#' Assumes there is a final, overall outcome Y to determine the optimal treatment 
#' sequence. 

.calcOptTxAndValFromPOs <- function(mu_df){
  mu_df <- mu_df %>% 
    group_by(ptid) %>% 
    mutate(maxMu = max(Mu),
           OptA1 = A1[which.max(Mu)],
           OptA2 = A2[which.max(Mu)],
           OutcomeUnderOpt = PO[which.max(Mu)],
           DeltaMu = Mu - maxMu,
           DeltaPO = PO - OutcomeUnderOpt,
           .groups = 'drop') %>% 
    ungroup
  
  return(mu_df)
}
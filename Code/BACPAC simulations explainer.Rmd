---
title: "BACPAC Simulation - Code explainer"
output: html_notebook
---

```{r packages_and_scripts, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(DynTxRegime)
scripts <- str_subset(list.files(recursive = TRUE), ".R$")
quietly(map(scripts, source))
```

__Overview of simulation code___

The basic skeleton for creating the simulation is the following:

Step 1: Generate participants and their covariates

a. Generate participants
b. Generate covariates

Step 2: Generate the trial

a. Allocate first-line treatments
b. Generate Y1 and responder status
c. Allocate second-line treatments
d. Generate Y2 
e. Generate Y 

Step 3: Wrap up Steps 1 and 2 in a wrapper to create many data sets

Step 4: map-reduce to put all the simulation data together (reduce optional)

Step 5: Analyze the simulation data sets and assess power given the simulation parameters

Step 6: Calculate performance metrics 

a. Generate an out-of-sample sample
b. Calculate power
c. Calculate in-sample metrics

__Steps 1 and 2__

Because the design of the trial is evolving, the simulation code is written with maximum flexibility and tractability in mind. Every simulation study starts with a plan which includes a design and a mechanism for generating participants and their outcomes. **The design and participants are operationalized through 8 functions choices where each function represents a key design or participant generation aspect.** The function choices are: 1. making participants, 2. making covariates, 3. allocating stage 1 treatments, 4. generating Y1, 5. assigning responder status, 6. allocating stage 2 treatments based on responder status, 7. generating Y2, and 8. generating Y. **The fundamental code design principle is to be tidy.** Specifically, the fundamental object is a dataframe that is piped through the 8 key functions and a dataframe is the yielded output. Once more of the design is nailed down, we may want to re-code this to utilize faster data objects.

I've made corresponding wrapper functions to show how functions you write/choose for each design choice should work. The first function is `makePpts()`. It is parameterized by an integer `N` and returns a dataframe with `N` rows and a single variable `ptid` (patient identifier).

```{r}
set.seed(309482)
# Some parameters we will need
N <- 100
firstLineTreatments <- as.character(1:6)
secondLineTreatments <- c("2", "3", "7", "8")
augmentationTreatments <- c("a1", "a2")

possibleTreatmentSequences <- generatePossibleTreatmentSequencesGrid(
  first_line_trts = firstLineTreatments,
  second_line_trts = secondLineTreatments,
  augment_trts = augmentationTreatments,
  impermissible_trt_pairs_df = NULL)

standardOfCareTreatment <- "1"

simDF <- makePpts(N = N)

simDF
```


The second function is `makeCovariates()`. Because this is a SMART and the goal is to answer precision medicine questions, generating covariates and relationship between them will be key. `makeCovariates()` takes the fundamental dataframe, a covariate generating function `covariateFn`, and related parametners for `covariateFn` and returns the fundamental dataframe with the covariates appended. 

Note that `covariateFn` is a function written to generate covariates. Check the library of written functions to see if there is a function that you can use or write your own to the library. In the snippet below, I have passed a function I wrote called `covariateFn_v1` and it takes 5 parameters (that are in the varargs position). 

```{r covar_settings}
### Covariate Generation Settings
covariateFunction <- covariateFn_v1
numBinaryCovariates <- 3 
numNormalCovariates <- 1

binaryCovarProps <- c(0.6, 0.5, 0.4)
normalCovarMu <- 0
normalCovarSd <- 1
```

```{r}
simDF <- simDF %>%
  makeCovariates(covariateFn = covariateFunction, 
                 numBinaryCovars = numBinaryCovariates, 
                 props = binaryCovarProps,
                 numNormalCovars = numNormalCovariates, 
                 mu = normalCovarMu, 
                 sd = normalCovarSd)

simDF
```

The third function is `allocateSTage1Treatments()`. It takes a function that defines how to allocate firstline treatments and associate parameters (varargs). Note that the firstline treatment assignment is named `A1`. Let's try to use this naming convention.

```{r}
simDF <- simDF %>%
   allocateStage1Treatments(allocationFn_stage1_v1, 
                             firstLineTreatments = firstLineTreatments)

simDF  
```

The fourth function is `generateY1()`. As you can see now, the general pattern is that each of the 8 key functions take a function and its associated parameters as its arguments. 

```{r}
simDF <- simDF %>%
  generateY1(generateY1Fn = generateNormalY1, 
               intercept = 3, 
               coefs = c("X_1" = .25, "W_1" = .1, 
                         "A1_1" = 1,
                         "A1_2" = -1,
                         "A1_3" = 0.5,
                         "A1_4" = 0.5,
                         "A1_1*X_1" = 0.75,
                         "A1_2*X_1" = 0.75,
                         "A1_4*X_1" = 0.2), 
               sigma = 1)

simDF
```

The fifth function is `assignResponderStatus()`, the sixth function is `allocateStage2Treatments()`, the seventh function is `generateY2()`, and the eighth function is `generateY()`.

```{r}
simDF <- simDF %>%  assignResponderStatus(assignResponderStatusByQuantile, 
                          ctsOutcome1 = Y1, cutoffs = c(0.2, 0.8)) %>%
    allocateStage2Treatments(allocationFn_stage2 = allocationFn_stage2_v1,
                             firstLineTreatments = firstLineTreatments,
                             secondLineTreatments = secondLineTreatments,
                             augmentationTreatments = augmentationTreatments,
                             standardOfCareTreatment = standardOfCareTreatment) %>%
    generateY2(generateY2Fn_v1, coefs = c("A1_1*X_1" = 1, "X_1" = 2, "A2_7*W_1" = 1),
               sigma = 1) %>%
    generateY(generateYFn = setYtoY2)
  
simDF
```


__Step 3__

Obviously, we don't want to go through each step for every simulation, so here is how you can wrap up the code into a single function. The only addition is a an additional column appended to each dataframe to keep track of which simulation data is being created. You will need to create metadata and args with the named elements as below. Note that the `args` list does exactly what we did above--for each step it lists a function name to use for the key step and the corresponding arguments. 

```{r}
metadata <- list(N = 600,
                 firstLineTreatments = as.character(1:6),
                 secondLineTreatments = c("2", "3", "7", "8"),
                 augmentationTreatments = c("a1", "a2"),
                 standardOfCareTreatment = "1")

possibleTreatmentSequences <- generatePossibleTreatmentSequencesGrid(
  first_line_trts = metadata$firstLineTreatments,
  second_line_trts = metadata$secondLineTreatments,
  augment_trts = metadata$augmentationTreatments,
  impermissible_trt_pairs_df = NULL)

args <- list(
  makePpts_fn = "makePpts",
  makePpts_args = list(metadata[["N"]]),
  makeCovariates_fn = "covariateFn_v1",
  makeCovariates_args = list(numBinaryCovars = 3, props = c(0.6, 0.5, 0.4),
                             numNormalCovars = 1, mu = 0, sd = 1),
  allocateStage1Treatments_fn = "allocationFn_stage1_v1",
  allocateStage1Treatments_args = list(metadata$firstLineTreatments),
  generateY1_fn = "generateNormalY1",
  generateY1_args = list(intercept = 1, 
                         coefs = c("X_1" = -1, "W_1" = 1, "A1_2*W_1" = 0.5), 
                         sigma = 1),
  assignResponderStatus_fn = "assignResponderStatusByQuantile",
  assignResponderStatus_args = list(ctsOutcome1 = "Y1", cutoffs = c(0.2, 0.8)),
  allocateStage2Treatments_fn = "allocationFn_stage2_v1",
  allocateStage2Treatments_args = list(firstLineTreatments = metadata$firstLineTreatments,
                                       secondLineTreatments = metadata$secondLineTreatments,
                                       augmentationTreatments = metadata$augmentationTreatments,
                                       standardOfCareTreatment = metadata$standardOfCareTreatment),
  generateY2_fn = "generateY2Fn_v1",
  generateY2_args = list(coefs = c("A1_1*X_1" = 1, "X_1" = 2, "A2_7*W_1" = 1),
                         sigma = 1),
  generateY_fn = "YforOneDominantRegime_v1",
  generateY_args = list(delta = 0.4,
                        sigma = 1))


ex_sim <- makeSimDataWrapper(metadata, args, 1) 

```


__Step 4__

Here's how you would use your wrapper function from Step 3 to make `L` simulation data sets. 

```{r}
set.seed(309482)

# Create L data sets
L <- 10
# allSimData <- reduce(map(1:L, makeSimDataWrapper, metadata = metadata, args = args), bind_rows)
allSimData <- map(1:L, makeSimDataWrapper, metadata = metadata, args = args)
sim_sum <- map_dfr(allSimData, 
                   ~summarise(.data = ., 
                              NConsistent = sum(consistent),
                              N_X11_S1_A1 = sum(X_1 == 1 & respStatus == "good" & A1 == "2"),
                              N_X11_S2_A2 = sum(X_1 == 1 & A1 == "2" & respStatus != "good" & A2 == "3"),
                              N_X10_S1_A4 = sum(X_1 == 0 & respStatus == "good" & A1 == "4"),
                              N_X10_S2_A2 = sum(X_1 == 0 & A1 == "4" & respStatus != "good" & A2 == "2"),
                              PropConsistent = mean(consistent), 
                              Prop_X1_A1 = N_X11_S1_A1/n(),
                              Prop_X11_S2_A2 = N_X11_S2_A2/n(),
                              Prop_X10_S1_A4 = N_X10_S1_A4/n(),
                              Prop_X10_S2_A2 = N_X10_S2_A2/n()))
map_dbl(allSimData, ~mean(.$consistent)) %>% summary
```

__Step 5__

Analyze the data sets we can estimate the optimal DTR using Q-learning. 

```{r}
moMain <- modelObj::buildModelObj(model = ~ X_1 + X_2 + X_3 + W_1,
                                  solver.method = 'lm')
moCont <- moMain

res <- map(allSimData, doQLearning, moMain_stage2 = moMain, moCont_stage2 = moCont,
            moMain_stage1 = moMain, moCont_stage1 = moCont)

res_both_stages <- map(allSimData, doQLearningListReturn, moMain_stage2 = moMain, moCont_stage2 = moCont,
            moMain_stage1 = moMain, moCont_stage1 = moCont)

estimatedValues <- map(res, estimator)

unlist(estimatedValues)
```


__Step 6__

We'll generate out-of-sample data from the same population

```{r oos_data}
oosDF <- makePpts(N = 1e3) %>%
   exec(args$makeCovariates_fn, !!!args$makeCovariates_args, df = .) 
```


And the expected and potential outcomes
```{r expectations_and_pos}
oosPOs <- oosDF %>% 
  calcTrueMeansAndPOs(indf = .,
                      trt_options_grid = possibleTreatmentSequences,
                      outcome_functions_list = list(args$generateY1_fn, 
                                                    args$generateY2_fn,
                                                    args$assignResponderStatus_fn,
                                                    args$generateY_fn),
                      outcome_args_list = list(args$generateY1_args,
                                               args$generateY2_args,
                                               args$assignResponderStatus_args,
                                               args$generateY_args))

```

Predict Treatment Sequences

```{r}

oosTrtSeqEstimates <- map(res_both_stages, ~predictTreatSequence(., newdata = oosDF))


```

Calculate Estimated Value and Percentage of Oracle Value

```{r}
oosVals <- map_dfr(oosTrtSeqEstimates, ~getValueDifSummary(., po_grid_df = oosPOs))
```


__Wrapper Example__


```{r, include=FALSE, echo=FALSE, message = FALSE}
# Alternate version of make binary covariates to make them take values in {-1, 1}
makeBinaryCovars <- function(df, numCovars, props){
  if(numCovars < 0){
    warning("Number of binary covariates must be non-negative")
  } else if(numCovars == 0){
    return(df)
  } else{
    covarNames <- paste("X", 1:numCovars, sep = "_")
    for(i in 1:numCovars){
      df <- df %>% rowwise() %>%
        mutate(!!sym(covarNames[i]) := 2*rbinom(n = 1, size = 1, prob = props[i])-1) %>%
        ungroup()
    }
    return(df)
  }
}
```

Generate simulated studies

```{r metadata_example, echo=FALSE, include=FALSE}
metadata <- list(N = 600,
                 firstLineTreatments = as.character(1:4),
                 secondLineTreatments = as.character(1:6),
                 standardOfCareTreatment = "1")

args <- list(
  makePpts_fn = "makePpts",
  makePpts_args = list(metadata[["N"]]),
  makeCovariates_fn = "covariateFn_v1",
  makeCovariates_args = list(numBinaryCovars = 3, props = c(0.6, 0.2, 0.4),
                             numNormalCovars = 1, mu = 0, sd = 1),
  allocateStage1Treatments_fn = "allocationFn_stage1_v1",
  allocateStage1Treatments_args = list(metadata$firstLineTreatments),
  generateY1_fn = "generateNormalY1",
  generateY1_args = list(intercept = 0.3, 
               coefs = c("X_1" = .25, "W_1" = .1, 
                         "A1_1" = 0.4,
                         "A1_2" = -0.4,
                         "A1_3" = 0.25,
                         "A1_4" = 0.25,
                         "A1_1*X_1" = 0.3,
                         "A1_2*X_1" = 0.3,
                         "A1_4*X_1" = 0.2), 
               sigma = sqrt(0.5)),
  assignResponderStatus_fn = "assignResponderStatusByQuantile",
  assignResponderStatus_args = list(ctsOutcome1 = "Y1", cutoffs = c(0.2, 0.8)),
  allocateStage2Treatments_fn = "allocationFn_stage2_v1",
  allocateStage2Treatments_args = list(firstLineTreatments = metadata$firstLineTreatments,
                                       secondLineTreatments = metadata$secondLineTreatments,
                                       augmentationTreatments = metadata$augmentationTreatments,
                                       standardOfCareTreatment = metadata$standardOfCareTreatment),
  generateY2_fn = "generateY2Fn_v1",
  generateY2_args = list(coefs = c(
    "A2_1*X_1" = -0.4, "A2_1*A1_3" = -0.4, "A2_1*A1_4" = 0.4,
    "A2_2" = -0.4, "A2_2*X_1" = 0.3, "A2_2*A1_1" = 0.2, "A2_2*A1_2" = -0.4, "A2_2*A1_3" = 0, "A2_2*A1_4" = 0.2,    
    "A2_3" = 0.2, "A2_3*X_1" = 0.4, "A2_3*A1_1" = 0, "A2_3*A1_2" = 0, "A2_3*A1_3" = -0.2, "A2_3*A1_4" = 0.4,
    "A2_4" = 0.2, "A2_4*X_1" = 0, "A2_4*A1_1" = -1, "A2_4*A1_2" = -0.3, "A2_4*A1_3" = 0, "A2_4*A1_4" = 0.2,  
    "A2_5" = 0.4, "A2_5*X_1" = -0.4, "A2_5*A1_1" = 0, "A2_5*A1_2" = 0, "A2_5*A1_3" = 0.2, "A2_5*A1_4" = 0.2,
    "A2_6" = 0, "A2_6*X_1" = 0.2, "A2_6*A1_1" = 0.2, "A2_6*A1_2" = -0.4, "A2_6*A1_3" = -0.4, "A2_6*A1_4" = -0.4),
    sigma = sqrt(0.5)),
  generateY_fn = "setYtoY2",
  generateY_args = list(NA))



```


```{r single_setting_example}
set.seed(8430)
# NC Pick 4 Daytime Draw 
# https://nclottery.com/Pick4

# Create L data sets
L <- 10

allSimData <- map(1:L, makeSimDataWrapper, metadata = metadata, args = args)

```

Generate out-of-sample data

```{r treatment_grid}
possibleTreatmentSequences <- generatePossibleTreatmentSequencesGrid(
  first_line_trts = metadata$firstLineTreatments,
  second_line_trts = metadata$secondLineTreatments,
  augment_trts = metadata$augmentationTreatments,
  impermissible_trt_pairs_df = NULL)

oos_metadata <-  list(nOOS = 1e3,
                 firstLineTreatments = metadata$firstLineTreatments,
                 secondLineTreatments = metadata$secondLineTreatments,
                 standardOfCareTreatment = metadata$standardOfCareTreatment)

oos_args <- list(
  makePpts_fn = args$makePpts_fn,
  makePpts_args = list(N = oos_metadata[["nOOS"]]),
  makeCovariates_fn = args$makeCovariates_fn,
  makeCovariates_args = args$makeCovariates_args,
  MakePOs_fn = "calcTrueMeansAndPOs",
  makePOs_args = list(trt_options_grid = possibleTreatmentSequences,
                        outcome_functions_list = list(args$generateY1_fn, 
                                                      args$generateY2_fn,
                                                      args$assignResponderStatus_fn,
                                                      args$generateY_fn),
                        outcome_args_list = list(args$generateY1_args,
                                                 args$generateY2_args,
                                                 args$assignResponderStatus_args,
                                                 args$generateY_args)))
# This is going to be a long data frame
oosData <-  make1OutofSampleSimDataSet(metadata = oos_metadata,
                             args = oos_args)

oosData
```

Calculate performance metrics

```{r analysis_settings}

# Model specification
moMain <- modelObj::buildModelObj(model = ~ X_1 + X_2 + X_3 + W_1,
                                  solver.method = 'lm')
moCont <- moMain

analysis_metadata <-  list(N = metadata$N,
                           nOOS = oos_metadata$nOOS,
                           firstLineTreatments = metadata$firstLineTreatments,
                           secondLineTreatments = metadata$secondLineTreatments,
                           standardOfCareTreatment = metadata$standardOfCareTreatment)

analysis_args <- list(AnalysisModeling_fn = "doQLearningListReturn",
                      AnalysisModeling_args = list("moMain_stage2" = moMain, 
                                                   "moCont_stage2" = moCont,
                                                   "moMain_stage1" = moMain, 
                                                   "moCont_stage1" = moCont),
                      PredictSequence_fn = "predictTreatSequence",
                      PredictSequence_args = NULL,
                      makeInSampleMetrics_fns = NULL,
                      makeInSampleMetrics_args_list = NULL,
                      makeOOSMetrics_fns = "",
                      makeOOSMetrics_args = list())

# This works a little differently than the other wrappers
# To avoid passing a list containing a list of data, specifically to avoid having
# args contain a list of the simulation data sets, there are two additional arguments

analysis_summary <- analyzeSimulationRunsPercOracleWrapper(metadata = analysis_metadata, 
                                       args = analysis_args,
                                       study.data.list = allSimData,
                                       oos.data = oosData)

analysis_summary
```